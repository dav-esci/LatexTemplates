---
url_color: "#48705D"
output:
  pdf_document:
    pandoc_args: --listings
    includes:
      in_header: ty.tex
      before_body: title_classic.tex
    latex_engine: pdflatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(kableExtra)
library(dplyr)
library(edgeR)  # 'edgeR' also loads 'limma' 
library(EnsDb.Hsapiens.v86)
library(Glimma)
library(SummarizedExperiment)
library(factoextra)
library(pheatmap)
library(glue)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(grid)
```

\thispagestyle{empty}
\tableofcontents

```{=tex}
\newpage
\pagenumbering{arabic}
```

\newpage

```{r, echo=FALSE, message=FALSE, results='hide', error=FALSE, warning=FALSE}
current.dir <- "/home/dabadav/Documents/ESCI/3TERM/Omics/RNA-seq"
setwd(current.dir)

latex.dir <- "/home/dabadav/Documents/LatexTemplates"
latex.files <- list.files(latex.dir, ".tex")

file.copy(glue("{latex.dir}/{latex.files}"), current.dir)
```

# 1) Introduction

A recent study by McClain et al. analyzed the host response to SARS-CoV-2 infection through RNA sequencing of peripheral blood samples from subjects with COVID-19, comparing them to subjects with seasonal coronavirus, influenza, bacterial pneumonia, and healthy controls. We will use the data generated by this study, publicly available at GEO under accession GSE161731, to perform a differential gene expression (DGE) analysis between conditions in R.

# 2) Data

## 2.1) Download RNA-seq data from GEO and load it into R, keep all 5 cohorts: COVID19, CoV_other, Influenza, Bacterial and healthy

The data generated by [McClain et al.](https://www.nature.com/articles/s41467-021-21289-y) is available as GEO series [GSE161731](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE161731).

```{r}
files_to_download <- c("GSE161731_counts.csv.gz",      # Gene expression (count matrix)
                       "GSE161731_counts_key.csv.gz")  # Metadata

# Download files
for (f in files_to_download) {
   if(!file.exists(glue("https://ftp.ncbi.nlm.nih.gov/geo/series/GSE161nnn/GSE161731/suppl/{f}"))){
     url <- glue("https://ftp.ncbi.nlm.nih.gov/geo/series/GSE161nnn/GSE161731/suppl/{f}")
     download.file(url, destfile = f)
   }
}

# Load both files in R
counts <- read.csv("GSE161731_counts.csv.gz", header = TRUE, check.names = FALSE, row.names = 1)
metadata <- read.csv("GSE161731_counts_key.csv.gz", header = TRUE, check.names = FALSE, row.names = 1)

# Obtain gene annotations
genes <- genes(EnsDb.Hsapiens.v86)
```

We can now build a SummarizedExperiment object:

```{r}
comm.s <- intersect(colnames(counts), rownames(metadata))       # Get common samples (in 'counts' and 'metadata')
comm.g <- intersect(rownames(counts), genes$gene_id)            # Get common genes (in 'counts' and the annotation)
se <- SummarizedExperiment(assay = list("counts" = counts[comm.g, comm.s]),
                           colData = metadata[comm.s, ],
                           rowRanges = genes[comm.g])
```

\newpage

```{r}
colData(se)[1:25, ] %>%
    kable(format = 'latex', booktabs = TRUE, caption = "First 25 rows of colData") %>%
    kable_styling(latex_options=c("scale_down", "HOLD_position"))
```

```{r}
rowRanges(se)[1:25, ] %>%
    kable(format = 'latex', booktabs = TRUE, caption = "First 25 rows of rowData") %>%
    kable_styling(latex_options=c("scale_down", "HOLD_position"))
```

\newpage

## 2.2) Data cleaning

Before performing any further analysis, we should clean the data up. Among others:

-   Remove duplicates

```{r}
# Count samples per condition
table(se$cohort) %>%
    kable(format = 'latex', booktabs = TRUE, col.names = c("Cohort","Num samples")) %>%
    kable_styling(latex_options="HOLD_position")
```

```{r}
# Some individuals have replicated measurments
table(table(se$subject_id)) %>%
    kable(format = 'latex', booktabs = TRUE, col.names = c("Num Measurments","Num individuals")) %>%
    kable_styling(latex_options="HOLD_position")
```

```{r}
# Removing replicated measurments 
se <- se[, !duplicated(se$subject_id)]

# Count samples per condition after filtering 
table(se$cohort) %>%
    kable(format = 'latex', booktabs = TRUE, col.names = c("Cohort", "Num samples")) %>%
    kable_styling(latex_options="HOLD_position")
```

-   Ensure that the variables are the appropriate class

```{r}
# Convert "age" to numeric
class(se$age)

se$age <- gsub(">89", "90", se$age)
se$age <- as.numeric(as.character(se$age))
class(se$age)
```

-   Metadata cleanup

```{r}
# Remove/modify some characters in the "cohort" and "race" columns
cols <- c("cohort", "race")
colData(se)[, cols] <- apply(colData(se)[, cols], 2, function(x){
  y <- gsub("-", "", x)   # Remove "-" 
  z <- gsub(" ", "_", y)  # Change " " (space) by "_"
  w <- gsub("/", "_", z)  # Change "/" by "_"
  return(w)
})

# Rename columns to individual id
colnames(se) <- se$subject_id

# Remove uninteresting columns
colData(se)[, c("subject_id", "time_since_onset", "hospitalized")] <- NULL

# Adding column of discrete age (dividing in different groups)
se$discrete_age <- cut(se$age, breaks = c(0, 12, 18, 30, 60, 120), labels = c("Child", "Teenager", "Young", "Adult", "Old"))

# colData after cleaning
colData(se)[1:15, ] %>%
    kable(format = 'latex', booktabs = TRUE, caption = "First 15 rows of cleaned colData") %>%
    kable_styling(latex_options=c("scale_down", "HOLD_position"))
```

## 2.3) Removal of lowly expressed genes

Genes that have very low counts across all the samples should be removed prior to downstream analysis. This is justified on both biological and statistical grounds. From a biological point of view, a gene must be expressed at some minimal level before it is likely to be translated into a protein or to be considered biologically relevant. From a statistical point of view, genes with consistently low counts are very unlikely assessed as significantly DE because low counts do not provide enough statistical evidence for a reliable judgement to be made. Such genes can therefore be removed from the analysis without any loss of information.

As a rule of thumb, we require that a gene have a count of at least k in at least n samples before it is considered to be expressed in the study. In practice, the filtering is actually based on count-per-million (CPM) values so as to avoid favoring genes that are expressed in larger libraries over those expressed in smaller libraries. The filtering can be accomplished using a function from the edgeR package that takes into account the library sizes and the experimental design:\*

```{r}
keep <- filterByExpr(se, group=se$cohort)
table(keep)
```

The SummarizedExperiment object is then subsetted to retain only the non-filtered genes:

```{r}
se <- se[keep, ]
```

The filterByExpr function attempts to keep the maximum number of interesting genes in the analysis, but other sensible filtering criteria are also possible. For example keep \<- rowSums(assays(se)\$counts) \> 50 or representing the histogram of the the median log2(CPM) for each gene, and choosing a cutoff value empirically.

\newpage

## 2.4) Data normalization

**Represent (e.g. via boxplots) the distribution of the TMM normalization factors per cohort.**

Here we will perform normalization by trimmed mean of M values (TMM). This is achieved using the calcNormFactors function. TMM calculates a set of normalization factors, one for each sample, to eliminate composition biases between libraries. The product of these factors and the library sizes defines the effective library size, which replaces the original library size in all downstream analyses. calcNormFactors returns a DGEList object. This object is a simple list-based S4 class object. It is easy to use as it can be manipulated like an ordinary list in R, and it can also be subsetted like a matrix. The main components of a DGEList object are a matrix of read counts, sample information in the data.frame format and optional gene annotation.

```{r, message=FALSE, results='hide', error=FALSE, warning=FALSE}
dgl <- calcNormFactors(se, method="TMM")
```

```{r, echo=FALSE, message=FALSE, results='hide', error=FALSE, warning=FALSE}
ggplot(dgl$samples, aes(x=cohort, y=norm.factors, fill = cohort)) +
     geom_boxplot() +
     ylab("Norm factors") +
     ggtitle("TMM normalization factors per cohort") +
     theme( legend.position = "none" )
```

**Which cohort has the smallest/largest (on average) normalization factors? How do you interpret this result?**

On average the *Bacterial* cohort has the smallest normalization factors, and the *Healthy* cohort has the largest normalization factor. Normalization factor mean value of the different cohorts multiply to 1, as Bacteria cohort presents mean normalization value below 1 this indicates that a small number of high count genes are monopolizing the sequencing, causing the counts for other genes presented in the other cohorts to be underrepresented. As a result, the effective library size will be scaled down for the genes in this cohort.

\newpage

# 3) Exploratory data analysis

## 3.1) Principal Component Analysis (PCA)

Roughly, PCA builds *principal components* (i.e. linear combinations of the variables of interest: the gene expression values), so that each of them captures as much variability from the original data as possible. We can use PCA to reduce the dimensionality of our data, from thousands of genes to 2 principal components, and thus represent our individuals in 2D (loosing some variability with respect to the original data, but gaining interpretability). The closer the individuals in this reduced space, the more similar they are with respect to the expression of their genes, and viceversa. PCA can help us to identify subgroups of individuals, outliers and batch effects. You can learn more about PCA [here](https://www.huber.embl.de/msmb/Chap-Multivariate.html).

**Perform Principal Component Analysis (PCA) on the normalized expression data.**

```{r, message=FALSE, results='hide', error=FALSE, warning=FALSE}
# Calculate CPM based on effective library size (using TMM normalization factors)
assays(se)$TMM <- cpm(dgl, normalized.lib.sizes = TRUE)

# Perform PCA on normalized expression data and plot
PCA <- prcomp(log2(t(assays(se)$TMM)+1))
fviz_pca_ind(PCA, addEllipses = T, col.ind = se$cohort, repel = TRUE, pointsize = 2) + labs(title="PCA - I")
```

\newpage

**Do you identify any outlier individual? If so, remove it and re-generate the PCA plot.**

-   Two outlier individuals were identified 896282, 613015.

```{r, message=FALSE, results='hide', error=FALSE, warning=FALSE}
# Remove Outlier
se <- se[, colnames(se) != "896282"]
se <- se[, colnames(se) != "613015"]

# Repeat the process
keep <- filterByExpr(se, group = se$cohort)
se <- se[keep, ]
dgl <- calcNormFactors(se, method = "TMM")

assays(se)$TMM <- cpm(dgl, normalized.lib.sizes = TRUE)
PCA <- prcomp(log2(t(assays(se)$TMM)+1)) 
fviz_pca_ind(PCA, addEllipses = T, col.ind = se$cohort, repel = TRUE, pointsize = 2) + labs(title="PCA - II")
```

\newpage

```{r}
pca_race <- fviz_pca_ind(PCA, addEllipses = T, col.ind = se$race, repel = TRUE, pointsize = 1, habillage=se$race, label="none") + labs(title="PCA (Colored by race)") + coord_quickmap()
pca_gender <- fviz_pca_ind(PCA, addEllipses = T, col.ind = se$gender, repel = TRUE, pointsize = 1, habillage=se$gender, label="none") + labs(title="PCA (Colored by gender)") + coord_quickmap()
```

```{r, echo=FALSE, message=FALSE, results='hide', error=FALSE, warning=FALSE}
ggarrange(pca_race, pca_gender, ncol = 1, heights = c(1,1))
```

\newpage

```{r}
pca_batch <- fviz_pca_ind(PCA, addEllipses = T, col.ind = as.character(se$batch), repel = TRUE, pointsize = 1, habillage=se$batch, label="none") + labs(title="PCA (Colored by batch)") + coord_quickmap()
pca_age <- fviz_pca_ind(PCA, addEllipses = T, col.ind = se$discrete_age, pointsize = 1, habillage=se$discrete_age, label="none") + labs(title="PCA (Colored by age)") + coord_quickmap()
```

```{r, echo=FALSE, message=FALSE, results='hide', error=FALSE, warning=FALSE}
ggarrange(pca_batch, pca_age, ncol = 1, heights = c(1,1))
```

**Based on the plot: which cohort differs the most from the others regarding gene expression? Out of the following cohort pairs: healthy & Influenza, healthy & COVID19, CoV_other & Influenza, which are the most similar cohorts regarding their average gene expression (you can use the group centroids to compare them)?**

Based on both *PCA I* and *PCA II* (with most relevant outliers removed) plots we can observe that the Bacterial cohort is the one differing the most from the other regarding gene expression. Before removing the outliers in PCA I plot COVID19 & Healthy cohorts seemed to be the most similar cohorts, but by looking at the PCA II plot we can see that the most similar cohorts regarding their average gene expression are **CoV_other & Influenza**.

**Hypothesize and discuss which could be the biological reason behind the expression similarities/differences between the cohorts. Remember that we are looking at the expression of genes in the patients whole blood. You may use also the results of the clustering below.**

These samples used in this analysis come from patients blood, we could state that the biological reason behind the expression similarities/differences between cohorts might be related with the fact that cells have the capacity to [express more or less of each molecule](https://med.stanford.edu/news/all-news/2016/07/cheap-blood-test-can-discriminate-between-bacterial-viral-infections.html), creating a pattern of gene expression that changes in response to external influences, including infections. We can observe this as all viruses (COVID19, CoV-other, Influenza) are clustering together further from Bacterial cohort which is clustering alone, demonstrating a different pattern of gene expression depending on the kind of infection affecting the organism.

\newpage

## 3.2) Clustering / Heatmap

**Generate a clustering/heatmap plot.**

Briefly, clustering algorithms allow to group the observations and/or variables in our dataset, according to their similarity (dissimilarity). The latter can be measured in many different ways (e.g. Euclidean distance, 1-correlation, etc.). As with PCA, clustering is helpful to identify subgroups of individuals, outliers and batch effects. You can learn more about clustering [here](https://www.huber.embl.de/msmb/Chap-Clustering.html).

```{r}
pheatmap(log2(assays(se)$TMM + 1), show_rownames = FALSE, annotation_col = as.data.frame(colData(se)))
```

**Analyze it together with the PCA plot colored by different variables. Discuss which variables could be potential confounders that should be included in your design matrix for differential gene expression analysis.**

By observing the heatmap distribution of the different cohorts and the PCA colored by the different variables we can see that age generates an slight effect on the expression level potentially being an confounder variable, as Teenagers seems to present a lower gene expression and Adults a higher one, also in the PCA age colored plot we can see that Old and Adults clusters are more dispersed in comparison to Teenager and Young groups which are more similar and present a smaller cluster size.

Race might be a potential confounder aswell as it is not totally homogeneously distributed by observing the heatmap, and by looking at the PCA race colored plot we can also denote a slight deficiency on gene expression on the Black Africa American race and a higly dispersed Unknown Not Reported race cluster.
